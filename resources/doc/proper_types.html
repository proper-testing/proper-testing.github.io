<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module proper_types</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="/" target="_top"><img src="/images/proper_tiny.png" align="right" border="0" alt="PropEr logo"></a></td></tr></table></div>
<hr>

<h1>Module proper_types</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Type manipulation functions and predefined types.
<p>Copyright © 2010-2011 Manolis Papadakis, Eirini Arvaniti and Kostis Sagonas</p>

<p><b>Version:</b> Jul 24 2011 20:53:32</p>
<p><b>Authors:</b> Manolis Papadakis.</p>

<h2><a name="description">Description</a></h2><p>Type manipulation functions and predefined types.</p>
  
   <h3><a name="Basic_types">Basic types</a></h3><p>
   This module defines all the basic types of the PropEr type system as
   functions. See the <a href="#index">function index</a> for an overview.</p>
  
   <p>Types can be combined in tuples or lists to produce other types. Exact
   values (such as exact numbers, atoms, binaries and strings) can be combined
   with types inside such structures, like in this example of the type of a
   tagged tuple: <code>{'result', integer()}</code>.</p>
  
   <p>When including the PropEr header file, all
   <a href="#index">API functions</a> of this module are automatically
   imported, unless <code>PROPER_NO_IMPORTS</code> is defined.</p>
  
   <h3><a name="Customized_types">Customized types</a></h3><p>   
The following operators can be applied to basic types in order to produce   
new ones:</p>
  
   <dl>
   <dt><code>?LET(&lt;Xs&gt;, &lt;Xs_type&gt;, &lt;In&gt;)</code></dt>
   <dd>To produce an instance of this type, all appearances of the variables
     in <code>&lt;Xs&gt;</code> are replaced inside <code>&lt;In&gt;</code> by their corresponding values in a
     randomly generated instance of <code>&lt;Xs_type&gt;</code>. It's OK for the <code>&lt;In&gt;</code> part to
     evaluate to a type - in that case, an instance of the inner type is
     generated recursively.</dd>
   <dt><code>?SUCHTHAT(&lt;X&gt;, &lt;Type&gt;, &lt;Condition&gt;)</code></dt>
   <dd>This produces a specialization of <code>&lt;Type&gt;</code>, which only includes those
     members of <code>&lt;Type&gt;</code> that satisfy the constraint <code>&lt;Condition&gt;</code> - that is,
     those members for which the function <code>fun(&lt;X&gt;) -&gt; &lt;Condition&gt; end</code> returns
     <code>true</code>. If the constraint is very strict - that is, only a small
     percentage of instances of <code>&lt;Type&gt;</code> pass the test - it will take a lot of
     tries for the instance generation subsystem to randomly produce a valid
     instance. This will result in slower testing, and testing may even be
     stopped short, in case the <code>constraint_tries</code> limit is reached (see the
     "Options" section in the documentation of the <a href="proper.html"><code>proper</code></a> module). If
     this is the case, it would be more appropriate to generate valid instances
     of the specialized type using the <code>?LET</code> macro. Also make sure that even
     small instances can satisfy the constraint, since PropEr will only try
     small instances at the start of testing. If this is not possible, you can
     instruct PropEr to start at a larger size, by supplying a suitable value
     for the <code>start_size</code> option (see the "Options" section in the
     documentation of the <a href="proper.html"><code>proper</code></a> module).</dd>
   <dt><code>?SUCHTHATMAYBE(&lt;X&gt;, &lt;Type&gt;, &lt;Condition&gt;)</code></dt>
   <dd>Equivalent to the <code>?SUCHTHAT</code> macro, but the constraint <code>&lt;Condition&gt;</code>
     is considered non-strict: if the <code>constraint_tries</code> limit is reached, the
     generator will just return an instance of <code>&lt;Type&gt;</code> instead of failing,
     even if that instance doesn't satisfy the constraint.</dd>
   <dt><code>?SHRINK(&lt;Generator&gt;, &lt;List_of_alt_gens&gt;)</code></dt>
   <dd>This creates a type whose instances are generated by evaluating the
     statement block <code>&lt;Generator&gt;</code> (this may evaluate to a type, which will
     then be generated recursively). If an instance of such a type is to be
     shrunk, the generators in <code>&lt;List_of_alt_gens&gt;</code> are first run to produce
     hopefully simpler instances of the type. Thus, the generators in the
     second argument should be simpler than the default. The simplest ones
     should be at the front of the list, since those are the generators
     preferred by the shrinking subsystem. Like the main <code>&lt;Generator&gt;</code>, the
     alternatives may also evaluate to a type, which is generated recursively.
     </dd>
   <dt><code>?LETSHRINK(&lt;List_of_variables&gt;, &lt;List_of_types&gt;, &lt;Generator&gt;)</code></dt>
   <dd>This is created by combining a <code>?LET</code> and a <code>?SHRINK</code> macro. Instances
     are generated by applying a randomly generated list of values inside
     <code>&lt;Generator&gt;</code> (just like a <code>?LET</code>, with the added constraint that the
     variables and types must be provided in a list - alternatively,
     <code>&lt;List_of_types&gt;</code> may be a list or vector type). When shrinking instances
     of such a type, the sub-instances that were combined to produce it are
     first tried in place of the failing instance.</dd>
   <dt><code>?LAZY(&lt;Generator&gt;)</code></dt>
   <dd>This construct returns a type whose only purpose is to delay the
     evaluation of <code>&lt;Generator&gt;</code> (<code>&lt;Generator&gt;</code> can return a type, which will
     be generated recursively). Using this, you can simulate the lazy
     generation of instances:
     <pre>         stream() -&gt; ?LAZY(frequency([ {1,[]}, {3,[0|stream()]} ])).</pre>
     The above type produces lists of zeroes with an average length of 3. Note
     that, had we not enclosed the generator with a <code>?LAZY</code> macro, the
     evaluation would continue indefinitely, due to the eager evaluation of
     the Erlang language.</dd>
   <dt><code>non_empty(&lt;List_or_binary_type&gt;)</code></dt>
   <dd>See the documentation for <a href="#non_empty-1"><code>non_empty/1</code></a>.</dd>
   <dt><code>noshrink(&lt;Type&gt;)</code></dt>
   <dd>See the documentation for <a href="#noshrink-1"><code>noshrink/1</code></a>.</dd>
   <dt><code>default(&lt;Default_value&gt;, &lt;Type&gt;)</code></dt>
   <dd>See the documentation for <a href="#default-2"><code>default/2</code></a>.</dd>
   <dt><code>with_parameter(&lt;Parameter&gt;, &lt;Value&gt;, &lt;Type&gt;)</code></dt>
   <dd>See the documentation for <a href="#with_parameter-3"><code>with_parameter/3</code></a>.</dd>
   <dt><code>with_parameters(&lt;Param_value_pairs&gt;, &lt;Type&gt;)</code></dt>
   <dd>See the documentation for <a href="#with_parameters-2"><code>with_parameters/2</code></a>.</dd>
   </dl>
  
   <h3><a name="Size_manipulation">Size manipulation</a></h3><p>
   The following operators are related to the <code>size</code> parameter, which controls
   the maximum size of produced instances. The actual size of a produced
   instance is chosen randomly, but can never exceed the value of the <code>size</code>
   parameter at the moment of generation. A more accurate definition is the
   following: the maximum instance of <code>size S</code> can never be smaller than the
   maximum instance of <code>size S-1</code>. The actual size of an instance is measured
   differently for each type: the actual size of a list is its length, while
   the actual size of a tree may be the number of its internal nodes. Some
   types, e.g. unions, have no notion of size, thus their generation is not
   influenced by the value of <code>size</code>. The <code>size</code> parameter starts at 1 and   
grows automatically during testing.</p>
  
   <dl>
   <dt><code>?SIZED(&lt;S&gt;, &lt;Generator&gt;)</code></dt>
   <dd>Creates a new type, whose instances are produced by replacing all
     appearances of the <code>&lt;S&gt;</code> parameter inside the statement block
     <code>&lt;Generator&gt;</code> with the value of the <code>size</code> parameter. It's OK for the
     <code>&lt;Generator&gt;</code> to return a type - in that case, an instance of the inner
     type is generated recursively.</dd>
   <dt><code>resize(&lt;New_size&gt;, &lt;Type&gt;)</code></dt>
   <dd>See the documentation for <a href="#resize-2"><code>resize/2</code></a>.</dd>
   </dl>
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-frequency">frequency()</a></h3>
<p><pre>frequency() = pos_integer()</pre></p>


<h3 class="typedecl"><a name="type-length">length()</a></h3>
<p><pre>length() = non_neg_integer()</pre></p>


<h3 class="typedecl"><a name="type-raw_type">raw_type()</a></h3>
<p><b>abstract datatype</b>: <tt>raw_type()</tt></p>
<p>You can consider this as an equivalent of <code><a href="#type-type">type()</a></code>.</p>

<h3 class="typedecl"><a name="type-size">size()</a></h3>
<p><pre>size() = non_neg_integer()</pre></p>


<h3 class="typedecl"><a name="type-type">type()</a></h3>
<p><b>abstract datatype</b>: <tt>type()</tt></p>
<p>  A type of the PropEr type system</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#any-0">any/0</a></td><td>All Erlang terms (that PropEr can produce).</td></tr>
<tr><td valign="top"><a href="#arity-0">arity/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(0, 255)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#atom-0">atom/0</a></td><td>All atoms.</td></tr>
<tr><td valign="top"><a href="#binary-0">binary/0</a></td><td>All binaries.</td></tr>
<tr><td valign="top"><a href="#binary-1">binary/1</a></td><td>All binaries with a byte size of <code>Len</code>.</td></tr>
<tr><td valign="top"><a href="#bitstring-0">bitstring/0</a></td><td>All bitstrings.</td></tr>
<tr><td valign="top"><a href="#bitstring-1">bitstring/1</a></td><td>All bitstrings with a bit size of <code>Len</code>.</td></tr>
<tr><td valign="top"><a href="#bool-0">bool/0</a></td><td>Equivalent to <a href="#boolean-0"><tt>boolean()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#boolean-0">boolean/0</a></td><td>The atoms <code>true</code> and <code>false</code>.</td></tr>
<tr><td valign="top"><a href="#byte-0">byte/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(0, 255)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#char-0">char/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(0, 1114111)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#choose-2">choose/2</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(Low, High)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#default-2">default/2</a></td><td>Adds a default value, <code>Default</code>, to <code>Type</code>.</td></tr>
<tr><td valign="top"><a href="#elements-1">elements/1</a></td><td>Equivalent to <a href="#union-1"><tt>union(Choices)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#exactly-1">exactly/1</a></td><td>Singleton type consisting only of <code>E</code>.</td></tr>
<tr><td valign="top"><a href="#fixed_list-1">fixed_list/1</a></td><td>All lists whose i-th element is an instance of the type at index i of
  <code>ListOfTypes</code>.</td></tr>
<tr><td valign="top"><a href="#float-0">float/0</a></td><td>Equivalent to <a href="#float-2"><tt>float(inf, inf)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#float-2">float/2</a></td><td>All floats between <code>Low</code> and <code>High</code>, bounds included.</td></tr>
<tr><td valign="top"><a href="#frequency-1">frequency/1</a></td><td>Equivalent to <a href="#weighted_union-1"><tt>weighted_union(Choices)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#function-2">function/2</a></td><td>All pure functions that map instances of <code>ArgTypes</code> to instances of
  <code>RetType</code>.</td></tr>
<tr><td valign="top"><a href="#function0-1">function0/1</a></td><td>Equivalent to <a href="#function-2"><tt>function(0, RetType)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#function1-1">function1/1</a></td><td>Equivalent to <a href="#function-2"><tt>function(1, RetType)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#function2-1">function2/1</a></td><td>Equivalent to <a href="#function-2"><tt>function(2, RetType)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#function3-1">function3/1</a></td><td>Equivalent to <a href="#function-2"><tt>function(3, RetType)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#function4-1">function4/1</a></td><td>Equivalent to <a href="#function-2"><tt>function(4, RetType)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#int-0">int/0</a></td><td>Small integers (bound by the current value of the <code>size</code> parameter).</td></tr>
<tr><td valign="top"><a href="#integer-0">integer/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(inf, inf)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#integer-2">integer/2</a></td><td>All integers between <code>Low</code> and <code>High</code>, bounds included.</td></tr>
<tr><td valign="top"><a href="#largeint-0">largeint/0</a></td><td>Equivalent to <a href="#integer-0"><tt>integer()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#list-0">list/0</a></td><td>Equivalent to <a href="#list-1"><tt>list(any())</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#list-1">list/1</a></td><td>All lists containing elements of type <code>ElemType</code>.</td></tr>
<tr><td valign="top"><a href="#loose_tuple-1">loose_tuple/1</a></td><td>Tuples whose elements are all of type <code>ElemType</code>.</td></tr>
<tr><td valign="top"><a href="#nat-0">nat/0</a></td><td>Small non-negative integers (bound by the current value of the <code>size</code>
  parameter).</td></tr>
<tr><td valign="top"><a href="#neg_integer-0">neg_integer/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(inf, -1)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#non_empty-1">non_empty/1</a></td><td>This is a predefined constraint that can be applied to random-length
  list and binary types (e.g.</td></tr>
<tr><td valign="top"><a href="#non_neg_float-0">non_neg_float/0</a></td><td>Equivalent to <a href="#float-2"><tt>float(0.0, inf)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#non_neg_integer-0">non_neg_integer/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(0, inf)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#noshrink-1">noshrink/1</a></td><td>Creates a new type which is equivalent to <code>Type</code>, but whose instances
  are never shrunk by the shrinking subsystem.</td></tr>
<tr><td valign="top"><a href="#number-0">number/0</a></td><td>Equivalent to <a href="#union-1"><tt>union([integer(), float()])</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#oneof-1">oneof/1</a></td><td>Equivalent to <a href="#union-1"><tt>union(Choices)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#orderedlist-1">orderedlist/1</a></td><td>All sorted lists containing elements of type <code>ElemType</code>.</td></tr>
<tr><td valign="top"><a href="#parameter-1">parameter/1</a></td><td>Equivalent to <a href="#parameter-2"><tt>parameter(Parameter, undefined)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#parameter-2">parameter/2</a></td><td>Returns the value associated with <code>Parameter</code>, or <code>Default</code> in case
  <code>Parameter</code> is not associated with any value.</td></tr>
<tr><td valign="top"><a href="#pos_integer-0">pos_integer/0</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(1, inf)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#range-2">range/2</a></td><td>Equivalent to <a href="#integer-2"><tt>integer(Low, High)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#real-0">real/0</a></td><td>Equivalent to <a href="#float-0"><tt>float()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#resize-2">resize/2</a></td><td>Overrides the <code>size</code> parameter used when generating instances of
  <code>Type</code> with <code>NewSize</code>.</td></tr>
<tr><td valign="top"><a href="#return-1">return/1</a></td><td>Equivalent to <a href="#exactly-1"><tt>exactly(E)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#shrink_list-1">shrink_list/1</a></td><td>A type that generates exactly the list <code>List</code>.</td></tr>
<tr><td valign="top"><a href="#string-0">string/0</a></td><td>Equivalent to <a href="#list-1"><tt>list(char())</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#term-0">term/0</a></td><td>Equivalent to <a href="#any-0"><tt>any()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#timeout-0">timeout/0</a></td><td>Equivalent to <a href="#union-1"><tt>union([non_neg_integer() | infinity])</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#tuple-0">tuple/0</a></td><td>Equivalent to <a href="#loose_tuple-1"><tt>loose_tuple(any())</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#tuple-1">tuple/1</a></td><td>All tuples whose i-th element is an instance of the type at index i of
  <code>ListOfTypes</code>.</td></tr>
<tr><td valign="top"><a href="#union-1">union/1</a></td><td>The union of all types in <code>ListOfTypes</code>.</td></tr>
<tr><td valign="top"><a href="#vector-2">vector/2</a></td><td>All lists of length <code>Len</code> containing elements of type <code>ElemType</code>.</td></tr>
<tr><td valign="top"><a href="#weighted_default-2">weighted_default/2</a></td><td>A specialization of <a href="#default-2"><code>default/2</code></a>, where <code>Default</code> and <code>Type</code> are
  assigned weights to be considered by the random instance generator.</td></tr>
<tr><td valign="top"><a href="#weighted_union-1">weighted_union/1</a></td><td>A specialization of <a href="#union-1"><code>union/1</code></a>, where each type in <code>ListOfTypes</code> is
  assigned a frequency.</td></tr>
<tr><td valign="top"><a href="#with_parameter-3">with_parameter/3</a></td><td>Associates the atom key <code>Parameter</code> with the value <code>Value</code> while
  generating instances of <code>Type</code>.</td></tr>
<tr><td valign="top"><a href="#with_parameters-2">with_parameters/2</a></td><td>Similar to <a href="#with_parameter-3"><code>with_parameter/3</code></a>, but accepts a list of
  <code>{Parameter, Value}</code> pairs.</td></tr>
<tr><td valign="top"><a href="#wunion-1">wunion/1</a></td><td>Equivalent to <a href="#weighted_union-1"><tt>weighted_union(FreqChoices)</tt></a>.
</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="any-0">any/0</a></h3>
<div class="spec">
<p><pre>any() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All Erlang terms (that PropEr can produce). For reasons of efficiency,
  functions are never produced as instances of this type.<br>
  CAUTION: Instances of this type are expensive to produce, shrink and instance-
  check, both in terms of processing time and consumed memory. Only use this
  type if you are certain that you need it.</p>

<h3 class="function"><a name="arity-0">arity/0</a></h3>
<div class="spec">
<p><pre>arity() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(0, 255)</tt></a>.</p>


<h3 class="function"><a name="atom-0">atom/0</a></h3>
<div class="spec">
<p><pre>atom() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All atoms. All atoms used internally by PropEr start with a '<code>$</code>', so
  such atoms will never be produced as instances of this type. You should also
  refrain from using such atoms in your code, to avoid a potential clash.
  Instances shrink towards the empty atom, ''.</p>

<h3 class="function"><a name="binary-0">binary/0</a></h3>
<div class="spec">
<p><pre>binary() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All binaries. Instances shrink towards the empty binary, <code>&lt;&lt;&gt;&gt;</code>.</p>

<h3 class="function"><a name="binary-1">binary/1</a></h3>
<div class="spec">
<p><pre>binary(Len :: <a href="#type-length">length()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All binaries with a byte size of <code>Len</code>.
  <code>Len</code> must be an Erlang expression that evaluates to a non-negative integer.
  Instances shrink towards binaries of zeroes.</p>

<h3 class="function"><a name="bitstring-0">bitstring/0</a></h3>
<div class="spec">
<p><pre>bitstring() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All bitstrings. Instances shrink towards the empty bitstring, <code>&lt;&lt;&gt;&gt;</code>.</p>

<h3 class="function"><a name="bitstring-1">bitstring/1</a></h3>
<div class="spec">
<p><pre>bitstring(Len :: <a href="#type-length">length()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All bitstrings with a bit size of <code>Len</code>.
  <code>Len</code> must be an Erlang expression that evaluates to a non-negative integer.
  Instances shrink towards bitstrings of zeroes</p>

<h3 class="function"><a name="bool-0">bool/0</a></h3>
<div class="spec">
<p><pre>bool() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#boolean-0"><tt>boolean()</tt></a>.</p>


<h3 class="function"><a name="boolean-0">boolean/0</a></h3>
<div class="spec">
<p><pre>boolean() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>The atoms <code>true</code> and <code>false</code>. Instances shrink towards <code>false</code>.</p>

<h3 class="function"><a name="byte-0">byte/0</a></h3>
<div class="spec">
<p><pre>byte() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(0, 255)</tt></a>.</p>


<h3 class="function"><a name="char-0">char/0</a></h3>
<div class="spec">
<p><pre>char() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(0, 1114111)</tt></a>.</p>


<h3 class="function"><a name="choose-2">choose/2</a></h3>
<div class="spec">
<p><pre>choose(Low :: integer() | inf, High :: integer() | inf) -&gt;
          <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(Low, High)</tt></a>.</p>


<h3 class="function"><a name="default-2">default/2</a></h3>
<div class="spec">
<p><pre>default(Default :: <a href="#type-raw_type">raw_type()</a>, Type :: <a href="#type-raw_type">raw_type()</a>) -&gt;
           <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Adds a default value, <code>Default</code>, to <code>Type</code>.
  The default serves as a primary shrinking target for instances, while it
  is also chosen by the random instance generation subsystem half the time.</p>

<h3 class="function"><a name="elements-1">elements/1</a></h3>
<div class="spec">
<p><pre>elements(Choices :: [<a href="#type-raw_type">raw_type()</a>, ...]) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#union-1"><tt>union(Choices)</tt></a>.</p>


<h3 class="function"><a name="exactly-1">exactly/1</a></h3>
<div class="spec">
<p><pre>exactly(E :: term()) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Singleton type consisting only of <code>E</code>. <code>E</code> must be an evaluated term.
  Also written simply as <code>E</code>.</p>

<h3 class="function"><a name="fixed_list-1">fixed_list/1</a></h3>
<div class="spec">
<p><pre>fixed_list(ListOfTypes ::
               maybe_improper_list(<a href="#type-raw_type">raw_type()</a>, <a href="#type-raw_type">raw_type()</a> | [])) -&gt;
              <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All lists whose i-th element is an instance of the type at index i of
  <code>ListOfTypes</code>. Also written simply as a list of types.</p>

<h3 class="function"><a name="float-0">float/0</a></h3>
<div class="spec">
<p><pre>float() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#float-2"><tt>float(inf, inf)</tt></a>.</p>


<h3 class="function"><a name="float-2">float/2</a></h3>
<div class="spec">
<p><pre>float(Low :: number() | inf, High :: number() | inf) -&gt;
         <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All floats between <code>Low</code> and <code>High</code>, bounds included.
  <code>Low</code> and <code>High</code> must be Erlang expressions that evaluate to floats, with
  <code>Low =&lt; High</code>. Additionally, <code>Low</code> and <code>High</code> may have the value <code>inf</code>, in
  which case they represent minus infinity and plus infinity respectively.
  Instances shrink towards 0.0 if <code>Low =&lt; 0.0 =&lt; High</code>, or towards the bound
  with the smallest absolute value otherwise.</p>

<h3 class="function"><a name="frequency-1">frequency/1</a></h3>
<div class="spec">
<p><pre>frequency(FreqChoices :: [{<a href="#type-frequency">frequency()</a>, <a href="#type-raw_type">raw_type()</a>}, ...]) -&gt;
             <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#weighted_union-1"><tt>weighted_union(Choices)</tt></a>.</p>


<h3 class="function"><a name="function-2">function/2</a></h3>
<div class="spec">
<p><pre>function(ArgTypes :: [<a href="#type-raw_type">raw_type()</a>] | arity(),
         RetType :: <a href="#type-raw_type">raw_type()</a>) -&gt;
            <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All pure functions that map instances of <code>ArgTypes</code> to instances of
  <code>RetType</code>. The syntax <code>function(Arity, RetType)</code> is also acceptable.</p>

<h3 class="function"><a name="function0-1">function0/1</a></h3>
<div class="spec">
<p><pre>function0(RetType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#function-2"><tt>function(0, RetType)</tt></a>.</p>


<h3 class="function"><a name="function1-1">function1/1</a></h3>
<div class="spec">
<p><pre>function1(RetType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#function-2"><tt>function(1, RetType)</tt></a>.</p>


<h3 class="function"><a name="function2-1">function2/1</a></h3>
<div class="spec">
<p><pre>function2(RetType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#function-2"><tt>function(2, RetType)</tt></a>.</p>


<h3 class="function"><a name="function3-1">function3/1</a></h3>
<div class="spec">
<p><pre>function3(RetType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#function-2"><tt>function(3, RetType)</tt></a>.</p>


<h3 class="function"><a name="function4-1">function4/1</a></h3>
<div class="spec">
<p><pre>function4(RetType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#function-2"><tt>function(4, RetType)</tt></a>.</p>


<h3 class="function"><a name="int-0">int/0</a></h3>
<div class="spec">
<p><pre>int() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Small integers (bound by the current value of the <code>size</code> parameter).
  Instances shrink towards <code>0</code>.</p>

<h3 class="function"><a name="integer-0">integer/0</a></h3>
<div class="spec">
<p><pre>integer() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(inf, inf)</tt></a>.</p>


<h3 class="function"><a name="integer-2">integer/2</a></h3>
<div class="spec">
<p><pre>integer(Low :: integer() | inf, High :: integer() | inf) -&gt;
           <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All integers between <code>Low</code> and <code>High</code>, bounds included.
  <code>Low</code> and <code>High</code> must be Erlang expressions that evaluate to integers, with
  <code>Low =&lt; High</code>. Additionally, <code>Low</code> and <code>High</code> may have the value <code>inf</code>, in
  which case they represent minus infinity and plus infinity respectively.
  Instances shrink towards 0 if <code>Low =&lt; 0 =&lt; High</code>, or towards the bound with
  the smallest absolute value otherwise.</p>

<h3 class="function"><a name="largeint-0">largeint/0</a></h3>
<div class="spec">
<p><pre>largeint() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-0"><tt>integer()</tt></a>.</p>


<h3 class="function"><a name="list-0">list/0</a></h3>
<div class="spec">
<p><pre>list() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#list-1"><tt>list(any())</tt></a>.</p>


<h3 class="function"><a name="list-1">list/1</a></h3>
<div class="spec">
<p><pre>list(ElemType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All lists containing elements of type <code>ElemType</code>.
  Instances shrink towards the empty list, <code>[]</code>.</p>

<h3 class="function"><a name="loose_tuple-1">loose_tuple/1</a></h3>
<div class="spec">
<p><pre>loose_tuple(ElemType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Tuples whose elements are all of type <code>ElemType</code>.
  Instances shrink towards the 0-size tuple, <code>{}</code>.</p>

<h3 class="function"><a name="nat-0">nat/0</a></h3>
<div class="spec">
<p><pre>nat() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Small non-negative integers (bound by the current value of the <code>size</code>
  parameter). Instances shrink towards <code>0</code>.</p>

<h3 class="function"><a name="neg_integer-0">neg_integer/0</a></h3>
<div class="spec">
<p><pre>neg_integer() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(inf, -1)</tt></a>.</p>


<h3 class="function"><a name="non_empty-1">non_empty/1</a></h3>
<div class="spec">
<p><pre>non_empty(ListType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>This is a predefined constraint that can be applied to random-length
  list and binary types (e.g. <a href="#list-0"><code>list/0</code></a>, <a href="#string-0"><code>string/0</code></a>,
  <a href="#binary-0"><code>binary/0</code></a>) to ensure that the produced values are never empty.</p>

<h3 class="function"><a name="non_neg_float-0">non_neg_float/0</a></h3>
<div class="spec">
<p><pre>non_neg_float() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#float-2"><tt>float(0.0, inf)</tt></a>.</p>


<h3 class="function"><a name="non_neg_integer-0">non_neg_integer/0</a></h3>
<div class="spec">
<p><pre>non_neg_integer() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(0, inf)</tt></a>.</p>


<h3 class="function"><a name="noshrink-1">noshrink/1</a></h3>
<div class="spec">
<p><pre>noshrink(Type :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Creates a new type which is equivalent to <code>Type</code>, but whose instances
  are never shrunk by the shrinking subsystem.</p>

<h3 class="function"><a name="number-0">number/0</a></h3>
<div class="spec">
<p><pre>number() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#union-1"><tt>union([integer(), float()])</tt></a>.</p>


<h3 class="function"><a name="oneof-1">oneof/1</a></h3>
<div class="spec">
<p><pre>oneof(Choices :: [<a href="#type-raw_type">raw_type()</a>, ...]) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#union-1"><tt>union(Choices)</tt></a>.</p>


<h3 class="function"><a name="orderedlist-1">orderedlist/1</a></h3>
<div class="spec">
<p><pre>orderedlist(ElemType :: <a href="#type-raw_type">raw_type()</a>) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All sorted lists containing elements of type <code>ElemType</code>.
  Instances shrink towards the empty list, <code>[]</code>.</p>

<h3 class="function"><a name="parameter-1">parameter/1</a></h3>
<div class="spec">
<p><pre>parameter(Parameter :: atom()) -&gt; term()</pre></p>
</div><p>Equivalent to <a href="#parameter-2"><tt>parameter(Parameter, undefined)</tt></a>.</p>


<h3 class="function"><a name="parameter-2">parameter/2</a></h3>
<div class="spec">
<p><pre>parameter(Parameter :: atom(), Default :: term()) -&gt; term()</pre></p>
</div><p>Returns the value associated with <code>Parameter</code>, or <code>Default</code> in case
  <code>Parameter</code> is not associated with any value.</p>

<h3 class="function"><a name="pos_integer-0">pos_integer/0</a></h3>
<div class="spec">
<p><pre>pos_integer() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(1, inf)</tt></a>.</p>


<h3 class="function"><a name="range-2">range/2</a></h3>
<div class="spec">
<p><pre>range(Low :: integer() | inf, High :: integer() | inf) -&gt;
         <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#integer-2"><tt>integer(Low, High)</tt></a>.</p>


<h3 class="function"><a name="real-0">real/0</a></h3>
<div class="spec">
<p><pre>real() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#float-0"><tt>float()</tt></a>.</p>


<h3 class="function"><a name="resize-2">resize/2</a></h3>
<div class="spec">
<p><pre>resize(NewSize :: <a href="#type-size">size()</a>, Type :: <a href="#type-raw_type">raw_type()</a>) -&gt;
          <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Overrides the <code>size</code> parameter used when generating instances of
  <code>Type</code> with <code>NewSize</code>. Has no effect on size-less types, such as unions.
  Also, this will not affect the generation of any internal types contained in
  <code>Type</code>, such as the elements of a list - those will still be generated
  using the test-wide value of <code>size</code>. One use of this function is to modify
  types to produce instances that grow faster or slower, like so:
  <pre>     ?SIZED(Size, resize(Size * 2, list(integer()))</pre>
  The above specifies a list type that grows twice as fast as normal lists.</p>

<h3 class="function"><a name="return-1">return/1</a></h3>
<div class="spec">
<p><pre>return(E :: term()) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#exactly-1"><tt>exactly(E)</tt></a>.</p>


<h3 class="function"><a name="shrink_list-1">shrink_list/1</a></h3>
<div class="spec">
<p><pre>shrink_list(List :: [term()]) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>A type that generates exactly the list <code>List</code>. Instances shrink towards
  shorter sublists of the original list.</p>

<h3 class="function"><a name="string-0">string/0</a></h3>
<div class="spec">
<p><pre>string() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#list-1"><tt>list(char())</tt></a>.</p>


<h3 class="function"><a name="term-0">term/0</a></h3>
<div class="spec">
<p><pre>term() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#any-0"><tt>any()</tt></a>.</p>


<h3 class="function"><a name="timeout-0">timeout/0</a></h3>
<div class="spec">
<p><pre>timeout() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#union-1"><tt>union([non_neg_integer() | infinity])</tt></a>.</p>


<h3 class="function"><a name="tuple-0">tuple/0</a></h3>
<div class="spec">
<p><pre>tuple() -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#loose_tuple-1"><tt>loose_tuple(any())</tt></a>.</p>


<h3 class="function"><a name="tuple-1">tuple/1</a></h3>
<div class="spec">
<p><pre>tuple(ListOfTypes :: [<a href="#type-raw_type">raw_type()</a>]) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All tuples whose i-th element is an instance of the type at index i of
  <code>ListOfTypes</code>. Also written simply as a tuple of types.</p>

<h3 class="function"><a name="union-1">union/1</a></h3>
<div class="spec">
<p><pre>union(ListOfTypes :: [<a href="#type-raw_type">raw_type()</a>, ...]) -&gt; <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>The union of all types in <code>ListOfTypes</code>. <code>ListOfTypes</code> can't be empty.
  The random instance generator is equally likely to choose any one of the
  types in <code>ListOfTypes</code>. The shrinking subsystem will always try to shrink an
  instance of a type union to an instance of the first type in <code>ListOfTypes</code>,
  thus you should write the simplest case first.</p>

<h3 class="function"><a name="vector-2">vector/2</a></h3>
<div class="spec">
<p><pre>vector(Len :: <a href="#type-length">length()</a>, ElemType :: <a href="#type-raw_type">raw_type()</a>) -&gt;
          <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>All lists of length <code>Len</code> containing elements of type <code>ElemType</code>.
  <code>Len</code> must be an Erlang expression that evaluates to a non-negative integer.</p>

<h3 class="function"><a name="weighted_default-2">weighted_default/2</a></h3>
<div class="spec">
<p><pre>weighted_default(Default :: {<a href="#type-frequency">frequency()</a>, <a href="#type-raw_type">raw_type()</a>},
                 Type :: {<a href="#type-frequency">frequency()</a>, <a href="#type-raw_type">raw_type()</a>}) -&gt;
                    <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>A specialization of <a href="#default-2"><code>default/2</code></a>, where <code>Default</code> and <code>Type</code> are
  assigned weights to be considered by the random instance generator. The
  shrinking subsystem will ignore the weights and try to shrink using the
  default value.</p>

<h3 class="function"><a name="weighted_union-1">weighted_union/1</a></h3>
<div class="spec">
<p><pre>weighted_union(ListOfTypes :: [{<a href="#type-frequency">frequency()</a>, <a href="#type-raw_type">raw_type()</a>}, ...]) -&gt;
                  <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>A specialization of <a href="#union-1"><code>union/1</code></a>, where each type in <code>ListOfTypes</code> is
  assigned a frequency. Frequencies must be Erlang expressions that evaluate to
  positive integers. Types with larger frequencies are more likely to be chosen
  by the random instance generator. The shrinking subsystem will ignore the
  frequencies and try to shrink towards the first type in the list.</p>

<h3 class="function"><a name="with_parameter-3">with_parameter/3</a></h3>
<div class="spec">
<p><pre>with_parameter(Parameter :: atom(),
               Value :: term(),
               Type :: <a href="#type-raw_type">raw_type()</a>) -&gt;
                  <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Associates the atom key <code>Parameter</code> with the value <code>Value</code> while
  generating instances of <code>Type</code>.</p>

<h3 class="function"><a name="with_parameters-2">with_parameters/2</a></h3>
<div class="spec">
<p><pre>with_parameters(PVlist :: [{atom(), term()}], Type :: <a href="#type-raw_type">raw_type()</a>) -&gt;
                   <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Similar to <a href="#with_parameter-3"><code>with_parameter/3</code></a>, but accepts a list of
  <code>{Parameter, Value}</code> pairs.</p>

<h3 class="function"><a name="wunion-1">wunion/1</a></h3>
<div class="spec">
<p><pre>wunion(FreqChoices :: [{<a href="#type-frequency">frequency()</a>, <a href="#type-raw_type">raw_type()</a>}, ...]) -&gt;
          <a href="proper_types.html#type-type">proper_types:type()</a></pre></p>
</div><p>Equivalent to <a href="#weighted_union-1"><tt>weighted_union(FreqChoices)</tt></a>.</p>

<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="/" target="_top"><img src="/images/proper_tiny.png" align="right" border="0" alt="PropEr logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jul 24 2011, 20:53:32.</i></p>
</body>
</html>
